## [1단계] 문제 이해 및 설계 범위 확정

### 구현할 기능

- 빠른 비디오 업로드
- 원활한 비디오 재생
- 재생 품질 선택 기능
- 낮은 인프라 비용(infrastructure cost)
- 높은 가용성과 규모 확장성, 그리고 안정성
- 지원 클라이언트: 모바일 앱, 웹브라우저, 스마트 TV
- 일간 능동 사용자 수 5백만
- 사용자가 평균적으로 소비하는 시간 30분
- 다국어 지원
- 비디오 크기는 최대 1GB

### 개략적 규모 추정

> 다음 추정치는 많은 것을 가정한 결과이다.
> 
- 일단 능동 사용자(DAU: Daily Active User) 수는 5백만(5milion)
- 한 사용자는 하루에 평균 5개의 비디오를 시청
- 10%의 사용자가 하루에 1비디오 업로드
- 비디오 평균 크기는 300MB
- 비디오 저장을 위해 매일 새로 요구되는 저장 용량 = `5백만 x 10% x 300MB = 150TB`
- CDN(Contents Delivery Network) 비용
    - **CDN이란 콘텐츠 전송 시간을 줄여주는 네트워크이다.** ([출처](https://code-lab1.tistory.com/261))
    - 클라우드 CDN을 통해 비디오를 서비스할 경우 CDN에서 나가는 데이터의 양에 따라 과금한다.
    - 아마존의 클라우드 프론트(CloudFront)를 CDN 솔루션으로 사용할 경우 100% 트래픽이 미국에서 발생한다고 가정하면 1GB당 $0.02의 요금이 발생한다.
        - 여기서는 문제를 단순화하기 위해 비디오 스트리밍 비용만 따진다.
    - 따라서 매일 발생하는 요금은 `5백만 x 5비디오 x 0.3GB x $0.02 = $150,000`

**→ 이 추정 결과에 따라 CDN으로 비디오를 서비스하는 것은 비용이 엄청나다.**

## [2단계] 개략적 설계안 제시 및 동의 구하기

- 여기서 제시하는 설계안은 CDN과 BLOB 스토리지의 경우 기존 클라우드 서비스를 활용한다.
- 개략적으로 이 시스템은 다음 세 개 컴포넌트로 구성된다.
    
    ![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/fbf20c97-225e-4af7-8a6d-bd5adaf8e689)

    - 단말(client): 컴퓨터, 모바일, 스마트 TV를 통해서 유튜브를 시청할 수 있다.
    - CDN: 비디오는 CDN에 저장한다. 재생 버튼을 누르면 CDN으로부터 스트리밍이 이루어진다.
    - API 서버: 비디오 스트리밍을 제외한 모든 요청은 API 서버가 처리한다. 피드 추천, 비디오 업로드 URL 생성, 메타데이터 데이터베이스와 캐시 갱신, 사용자 가입 등등이 API 서버가 처리하는 작업이다.

### 비디오 업로드 절차

> 해당 설계안은 다음과 같은 컴포넌트들로 구성되어 있다.
> 

![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/8d6f5d42-84a6-402a-8a48-41753a85b32a)

- 사용자: 컴퓨터나 모바일 폰, 스마트 TV를 통해 유튜브를 시청하는 이용자
- 로드밸런서: API 서버 각각으로 고르게 요청을 분산하는 역할을 담당한다.
- API 서버: 비디오 스트리밍을 제외한 다른 모든 요청을 처리한다.
- 메타데이터 데이터베이스(metadata db): 비디오의 메타데이터를 보관한다.
    - 샤딩(sharding)과 다중화(replication)를 적용하여 성능 및 가용성 요구 사항을 충족한다.
    - 메타 데이터란 속성정보와 같은 데이터에 대한 설명 데이터를 의미한다. ([출처](https://whoishoo.tistory.com/226))
- 메타데이터 캐시(metadata cache): 성능을 높이기 위해 비디오 메타데이터와 사용자 객체는 캐시한다.
- 원본 저장소(original storage): 원본 비디오를 보관할 대형 이진 파일 저장소(BLOB, Binary Large Object Storage) 시스템이다.
    - BLOB 저장소는 ‘이진 데이터를 하나의 개체로 보관하는 데이터베이스 관리 시스템’이다. ([참고 자료](https://www.cloudflare.com/ko-kr/learning/cloud/what-is-blob-storage/), [참고 자료 2](https://github.com/techeer-TIL-group/yu-heejin/blob/main/React/blob.md))
- 트랜스코딩 서버(transcoding server): 비디오 트랜스코딩은 비디오 인코딩이라 부르기도 하는 절차로, 비디오의 포맷(MPEG, HLS 등)을 변환하는 절차이다.
    - 단말이나 대역폭 요구사항에 맞는 최적의 비디오 스트림을 제공하기 위해 필요하다.
    - **트랜스코딩 이란?** 아주 간단하게 말하면 재생하는 디바이스(디바이스=재생장치=스마트폰, PC)가 영상의 코덱을 지원할지 못할 경우 실시간으로 인코딩을 하여 재생이  가능하도록 해주는 것 ([출처](https://blog.naver.com/dna2073/221111113511))
- 트랜스 코딩 비디오 저장소(transcoded storage): 트랜스코딩이 완료된 비디오를 저장하는 BLOB 저장소이다.
- CDN: 비디오를 캐시하는 역할을 담당한다. 사용자가 재생 버튼을 누르면 비디오 스트리밍은 CDN을 통해 이루어진다.
- 트랜스코딩 완료 큐(completion queue): 비디오 트랜스코딩 완료 이벤트들을 보관할 메시지 큐이다.
- 트랜스코딩 완료 핸들러(completion handler): 트랜스코딩 완료 큐에서 이벤트 데이터를 꺼내어 메타 데이터 캐시와 데이터베이스를 갱신할 작업 서버들이다.
- 비디오 업로드는 다음과 같은 두 프로세스가 병렬적으로 수행된다.
    1. 비디오 업로드
    2. 비디오 메타데이터 갱신, 메타데이터에는 비디오 URL, 크기, 해상도, 포맷, 사용자 정보가 포함된다.

**프로세스 a: 비디오 업로드**

![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/f4058aa5-f6ec-4a27-bbfd-dcc55f0a2405)

1. 비디오를 원본 저장소에 업로드한다.
2. 트랜스코딩 서버는 원본 저장소에서 해당 비디오를 가져와 트랜스코딩을 시작한다.
3. 트랜스코딩이 완료되면 아래 두 절차가 병렬적으로 수행된다.
    1. 완료된 비디오를 트랜스코딩 비디오 저장소로 업로드한다.
    2. 트랜스코딩 완료 이벤트를 트랜스코딩 완료 큐에 넣는다.
        1. 트랜스 코딩이 끝난 비디오를 CDN에 올린다.
        2. 완료 핸들러가 이벤트 데이터를 큐에서 꺼낸다.
        3. 완료 핸들러가 메타 데이터 데이터베이스와 캐시를 갱신한다.
4. API 서버가 단말에게 비디오 업로드가 끝나서 스트리밍 준비가 되었음을 알린다.

**프로세스 b: 메타 데이터 갱신 (메타데이터는 왜 저장하는가?)**

![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/84aadf5a-0b98-4d47-9441-a839cb13cf2f)

- 원본 저장소에 파일이 업로드 되는 동안, 단말은 병렬적으로 비디오 메타데이터 갱신 요청을 API 서버에 보낸다.
    - 이 요청에 포함된 메타데이터에는 파일 이름, 크기, 포맷 등의 정보가 들어있다.
    - API 서버는 이 정보로 메타데이터 캐시와 데이터베이스를 업데이트한다.

### 비디오 스트리밍 절차

- 유튜브에서 비디오 재생버튼을 누르면 스트리밍은 바로 시작되며, 비디오 다운로드가 완료되어야 영상을 볼 수 있다거나 하는 불편함은 없다.
    - 여기서 다운로드는 비디오를 단말로 내려받는 것을 의미하며, 스트리밍은 사용자의 장치가 원격지의 비디오로부터 지속적으로 비디오 스트림을 전송 받아 영상을 재생하는 것을 말한다.
- 비디오 스트리밍이 이루어지는 절차를 논하기 앞서 우리는 먼저 **스트리밍 프로토콜(Streaming Protocol)**이라는 중요한 개념을 알아두어야 한다.
    - 스트리밍 프로토콜은 비디오 스트리밍을 위해 데이터를 전송할 때 쓰이는 표준화된 통신 방법이다.
    - 널리 사용되는 스트리밍 프로토콜로는 다음과 같은 종류가 있다.
        - MPEG-DASH: MPEG는 ‘Moving Picture Experts Group’의 약어이며, DASH는 ‘Dynamic Adaptive Streaming over HTTP’의 약어이다.
        - Apple HLS: HLS는 ‘HTTP Live Streaming’의 약어이다.
        - 마이크로소프트 스무드 스트리밍(Microsoft Smooth Streaming)
        - 어도비 HTTP 동적 스트리밍(Adobe HTTP Dynamic Streaming, HDS)
- **비디오는 CDN에서 바로 스트리밍된다.**
    - 사용자의 단말에 가장 가까운 CDN 에지 서버(edge server)가 비디오 전송을 담당하기 때문에 전송 지연이 낮다.
        ![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/54b103e1-ee7d-4e6e-a989-0ffe7b2db23d)

## [3단계] 상세 설계

### 비디오 트랜스코딩

- 비디오를 녹화하면 단말(보통 전화나 카메라)은 해당 비디오를 특정 포맷으로 저장한다.
- 이 비디오가 다른 단말에서도 순조롭게 재생되려면 다른 단말과 호환되는 비트레이트(bitrate)와 포맷으로 저장되어야한다.
    - 비트레이트는 비디오를 구성하는 비트가 얼마나 빨리 처리되어야 하는지를 나타내는 단위이다.
    - 비트레이트가 높은 비디오는 일반적으로 고화질이기 때문에 비트레이트가 높은 비디오 스트림을 정상 재생하려면 보다 높은 성능의 컴퓨팅 파워가 필요하고 인터넷 회선 속도도 빨라야한다.
    - 비트레이트란 1초에 해당하는 동영상에 얼마의 비트(bit) 수를 집어 넣느냐를 의미합니다. 즉, 이 비트레이트가 높을수록 동영상은 더 많은 정보(비트)를 가지게 되므로 화질은 더 좋아지게 됩니다. 하지만 비트레이트를 많이 집어 넣으면 넣을 수록 비트의 수는 그만큼 커지게 되므로 용량 또한 더 커지게 됩니다. (https://m.blog.naver.com/PostView.naver?blogId=dv1394&logNo=130133876897&proxyReferer=)
- 비디오 트랜스코딩의 중요성은 다음과 같다.
    - 가공되지 않은 원본 비디오는 저장 공간을 많이 차지한다. 가령, 초당 60 프레임으로 녹화된 HD 비디오는 수백 GB의 저장공간을 차지하게 될 수 있다.
    - 상당수의 단말과 브라우저는 특정 종류의 비디오 포맷만 지원한다. 따라서 호환성 문제를 해결하려면 하나의 비디오를 여러 포맷으로 인코딩해두는 것이 바람직하다.
    - 사용자에게 끊김 없는 고화질 비디오 재생을 보장하려면 네트워크 대역폭이 충분하지 않은 사용자에게는 저화질 비디오를, 대욕폭이 충분한 사용자에게는 고화질 비디오를 보내는 것이 바람직하다.
    - 모바일 단말의 경우 네트워크 상황이 수시로 달라질 수 있다. 비디오가 끊김 없이 재생되도록 하기 위해서는 비디오 화질을 자동으로 변경하거나 수동으로 변경할 수 있도록 하는 것이 바람직하다.
- 인코딩 포맷은 다양하지만 대부분 다음 두 부분으로 구성되어 있다.
    - 컨테이너(container): 비디오 파일, 오디오, 메타데이터를 담는 바구니같은 것으로, 컨테이너 포맷은 `.avi`, `.mov`, `.mp4`같은 파일 확장자를 보면 알 수 있다.

        ![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/92fab284-b754-44ee-950c-7b5b29d554eb)

        - **컨테이너 포맷**은**"비디오"**와**"오디오"**를 담아두는**"상자"**나 포장해 둔**"포장지"**그 쯤으로 생각하시면 충분합니다. ([동영상의 기본적인 이해 (컨테이너 포맷이란?, 동영상의 변환이란?)](https://blog.naver.com/dbfan24/10128721121))
    - 코덱(codec): 비디오 화질은 보존하면서 파일 크기를 줄일 목적으로 고안된 압축 및 압축 해제 알고리즘이다.
        - 가장 많이 사용되는 비디오 코덱으로는 `H.264`, `VP9`, `HEVC`가 있다.

### 유향 비순환 그래프(DAG) 모델

- 비디오를 트랜스코딩하는 것은 컴퓨팅 자원을 많이 소모할 뿐 아니라 시간도 많이 드는 작업이다.
- 게다가 콘텐츠 창작자는 각자 자기만의 비디오 프로세싱 요구사항을 갖고 있다.
    - 예를 들어 어떤 사람은 비디오 위에 워터마크를 표시하고 싶고, 어떤 사람은 섬네일 이미지를 자기가 손수 만들어 쓰고싶어 한다.
    - 어떤 사람은 고화질 비디오를 선호하는 반면 또 다른 어떤 사람은 저화질 비디오도 충분하다고 생각한다.
- **각기 다른 유형의 비디오 프로세싱 파이프라인을 지원**하는 한편 처리 과정의 병렬성을 높이기 위해서는 **적절한 수준의 추상화를 도입하여 클라이언트 프로그래머로 하여금 실행할 작업을 손수 정의할 수 있도록** 해야한다.
    - 예를 들어 페이스북의 스트리밍 비디오 엔진은 유향 비순환 그래프(DAG: Directed Acyclic Graph) 프로그래밍 모델을 도입, 작업을 단계별로 배열할 수 있도록 하여 해당 작업들이 순차적 또는 병렬적으로 실행될 수 있도록 한다. ([상세 내용](https://m.blog.naver.com/mckimstory/221876888519))
    
    ```
    💡 좀 쉽게 설명해서,, 유튜브를 보더라도 누구는 네트워크가 안 좋아서 저화질로 보거나 
    혹은 퇴근하고 맛있는거 먹으면서 고화질로 볼 수 있잖아요? 
    유튜버들도 워터마크 달고 섬네일도 커스텀하는 등 영상도 다양하게 편집하니까 
    처리 방법이 좀 다양하려면 클라이언트 단에서 사용자가 직접 설정하고 
    그에 맞게 서버에서 처리할 수 있도록 설계하자는 말인 것 같습니다.
    
    유향 비순환 그래프 프로그래밍 모델을 도입하면 단계별로 배열하거나 병렬적으로 처리할 수
    있는데, 이는 그림을 직접 그려보시면 이해하기 편하실거에요. (위상정렬 생각하시면 쉬울 듯!)
    ```
    
- 다음 이미지는 비디오 트랜스코딩을 위해 채택한 DAG 모델이다.

    ![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/d59cde97-cb39-4b73-99d7-d7ba55637edd)

    - 원본 비디오는 비디오, 오디오, 메타데이터 세 부분으로 나뉘어 처리된다.
    - 비디오 부분에 적용되는 작업은 다음과 같다.
        - 검사(inspection): 좋은 품질의 비디오인지, 손상은 없는지 확인하는 작업
        - 비디오 인코딩(video encoding): 비디오를 다양한 해상도, 코덱, 비트레이트 조합으로 인코딩하는 작업 (결과물 이미지)
        - 섬네일(thumbnail): 사용자가 업로드한 이미지나 비디오에서 자동 추출된 이미지로 섬네일을 만드는 작업
        - 워터마크(watermark): 비디오에 대한 식별정보를 이미지 위에 오버레이(overlay) 형태로 띄워 표시하는 작업

### 비디오 트랜스코딩 아키텍처

![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/a9e87636-98ba-46a5-b72b-5db164411a74)

- 위 아키텍처가 동작한 결과로 인코딩된 비디오가 만들어진다.
- 해당 아키텍처는 전처리기, DAG 스케줄러, 자원 관리자, 작업 실행 서버, 임시 저장소 다섯 개의 컴포넌트로 구성된다.

**전처리기**

- 전처리기가 하는 일은 다음 세 가지이다.
    1. 비디오 분할: 비디오 스트림을 GOP(Group of Pictures)라고 불리는 단위로 쪼갠다. GOP는 특정 순서로 배열된 프레임 그룹이다. 하나의 GOP는 독립적으로 재생 가능하며, 길이는 보통 몇 초 정도이다. 어떤 종류의 오래된 단말이나 브라우저는 GOP 단위의 비디오 분할을 지원하지 않는다. 그런 단말의 경우에는 전처리기가 비디오 분할을 대신한다. (https://tell-mia.tistory.com/46) → **요약하자면 동적인 프레임 위주로 그 경계를 나눈다는 의미입니다.**
  
        ![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/5b0422dd-f7d0-4923-b07d-ec8cea0cccc9)

    2. DAG 생성: 클라이언트 프로그래머가 작성한 설정 파일에 따라 DAG를 만들어낸다.
        
        ![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/a127ebcb-fd5e-4fcb-9f6d-a5e911654ac7)

    3. 데이터 캐시: 전처리기는 분할된 비디오의 캐시이기도 하다. 안정성을 높이기 위해 전처리기는 GOP와 메타데이터를 임시 저장소(temporary storage)에 보관한다. **비디오 인코딩이 실패하면 시스템은 이렇게 보관된 데이터를 활용해 인코딩을 재개한다.**

**DAG 스케줄러**

- DAG 스케줄러는 DAG 그래프를 몇 개 단계(stage)로 분할한 다음에 그 각각을 자원 관리자의 작업 큐에 집어넣는다. (위상 정렬)
    ![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/a872f66e-a764-438f-9a85-4508ee267d9a)

    - 위 이미지는 하나의 DAG 그래프를 2개 작업 단계로 쪼갠 사례이다.
    - 첫번째 단계에서는 비디오, 오디오, 메타데이터를 분리하고, 두 번째 단계에서는 해당 비디오 파일을 인코딩하고 섬네일을 추출하며, 오디오 파일 또한 인코딩한다.

**자원 관리자**

- 자원 관리자(resource manager)는 자원 배분을 효과적으로 수행하는 역할을 담당한다.
- 아래와 같이 세 개의 큐와 작업 스케줄러로 구성된다.
    
    ![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/adc2aa62-43cc-441d-a5e5-5153d27b3e21)

    - 작업 큐(task queue): 실행할 작업이 보관되어 있는 우선순위 큐(priority queue)이다.
    - 작업 서버 큐(task queue): 작업 서버의 가용 상태 정보가 보관되어 있는 우선순위 큐
    - 실행 큐(running queue): 현재 실행중인 작업 및 작업 서버 정보가 보관되어 있는 큐
    - 작업 스케줄러: 최적의 작업/서버 조합을 골라 해당 작업 서버가 작업을 수행하도록 지시하는 역할을 담당한다.
- 자원 관리자는 다음과 같이 동작한다.
    1. 작업 스케줄러는 작업 큐에서 가장 높은 우선 순위의 작업을 꺼낸다.
    2. 작업 스케줄러는 해당 작업을 실행하기 적합한 작업 서버를 고른다.
    3. 작업 스케줄러는 해당 작업 서버에게 작업 실행을 지시한다.
    4. 작업 스케줄러는 해당 작업이 어떤 서버에게 할당되었는지에 관한 정보를 실행 큐에 넣는다.
    5. 자원 관리자는 작업이 완료되면 해당 작업을 실행 큐에서 제거한다.

**작업 서버**

![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/8b079ab7-66ad-4ad9-ad99-45588bec0124)

- 작업 서버는 DAG에 정의된 작업을 수행하며, 작업 종류에 따라 작업 서버도 구분하여 관리한다.

**임시 저장소**

- 임시 저장소 구현에는 여러 저장소 시스템을 활용할 수 있다.
- 어떤 시스템을 선택할 것이냐는 저장할 데이터의 유형, 크기, 이용 빈도, 데이터 유효기간 등에 따라 달라진다.
    - 예를 들어 메타데이터는 작업 서버가 빈번히 참조하는 정보이고 그 크기도 작은 것이 보통이다. → 따라서 메모리에 캐시해두면 좋을 것이다.
    - 하지만 비디오/오디오 데이터는 BLOB 저장소에 두는 것이 바람직하다.
    - 임시 저장소에 보관한 데이터는 비디오 프로세싱이 완료되면 삭제한다.

**인코딩된 비디오**

- 인코딩된 비디오는 인코딩 파이프라인의 최종 결과물이다.

### 시스템 최적화

**속도 최적화: 비디오 병렬 업로드**

- 비디오를 전부 한 번에 업로드하는 것은 비효율적이며, 하나의 비디오는 작은 GOP들로 분할할 수 있다.
    
    ![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/27a2b421-ce88-4019-aaa7-161237c601bc)

- 분할한 GOP를 병렬적으로 업로드하면 일부가 실패해도 빠르게 업로드를 재개할 수 있다.
    - 따라서 비디오를 GOP 경계에 맞춰 분할하는 작업을 단말이 수행하면 업로드 속도를 높일 수 있다.

        ![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/7646b4e7-3ce1-4dff-b949-d114917fa1e5)

**속도 최적화: 업로드 센터를 사용자 근거리에 지정**

- 업로드 속도를 개선하는 또 다른 방법은 업로드 센터를 여러 곳에 두는 것이다.
- 따라서 CDN을 각 업로드 센터(에지 서버)로 보낸다.

**속도 최적화: 모든 절차를 병렬화**

- 응답 지연을 줄이는 것은 어려운 일이며, 이를 위해 시도해볼 수 있는 방법은 **느슨하게 결합된 시스템을 만들어 병렬성을 높이는 것이다.**

![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/42737ef5-e939-4237-8e31-9d940ba7e5c6)

- 위 절차를 보면 어떤 단계의 결과물은 이전 단계의 결과물을 입력으로 사용하여 만들어진다는 것을 알 수 있다.
    - 이러한 의존성이 있는 경우 병렬성을 높이기 어렵다.
- 위 프로그램의 결합도를 낮추기 위해 **메시지 큐를 도입한다.**
- 메세지 큐를 도입하면 다음과 같은 방법으로 결합도를 낮춘다.
    - 메세지 큐를 도입하기 전에는 인코딩 모듈은 다운로드 모듈의 작업이 끝나기를 기다려야 한다.
    - 메세지 큐를 도입한 뒤 인코딩 모듈은 다운로드 모듈의 작업이 끝나기를 더 이상 기다릴 필요가 없다. **메세지 큐에 보관된 이벤트 각각을 인코딩 모듈은 병렬적으로 처리할 수 있다.** 

        ![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/41cf01bc-a362-43ad-9d38-5d1842ef9e5a)

**안전성 최적화: 미리 사인된 업로드 URL**

- 허가받은 사용자만이 올바른 장소에 비디오를 업로드할 수 있도록 하기 위해 아래와 같이 미리 사인된 업로드 URL을 사용할 수 있다.

    ![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/de52d7d8-0d18-4926-b380-5a9695140645)

    1. 클라이언트는 HTTP 서버에 POST 요청을 하여 미리 사인된 URL(pre-signed)을 받는다. 해당 URL이 가리키는 객체(Object)에 대한 접근 권한이 이미 주어져 있는 상태이다. ‘미리 사인된 URL’이라는 용어는 사실 아마존 S3에서 쓰이는 용어이다. ([https://inpa.tistory.com/entry/AWS-📚-S3-Pre-signed-URL-공유하기](https://inpa.tistory.com/entry/AWS-%F0%9F%93%9A-S3-Pre-signed-URL-%EA%B3%B5%EC%9C%A0%ED%95%98%EA%B8%B0)) 다른 클라우드 업체는 다른 이름을 사용할 수도 있다.
        1. 예를 들어 마이크로 소프트 Azure에서 제공하는 BLOB 저장소는 같은 기능을
         ‘접근 공유 시그니처(Shared Access Signature)’라 부른다.
        
        ```
        💡 쉽게 말해 어떤 자원에 접근하기 위해 임시 주소를 통해 접근 권한을 주는 것
        (일정 시간 이후 삭제)
        ```
        
    2. API 서버는 미리 사인된 URL을 돌려준다.
    3. 클라이언트는 해당 URL이 가리키는 위치에 비디오를 업로드한다.

**안전성 최적화: 비디오 보호**

- 디지털 저작권 관리 시스템 도입
- AES 암호화
- 워터마크

**비용 최적화**

- CDN은 시스템의 핵심 부분이다. ~~(그래서 비싸다)~~
- 연구 결과에 따르면 유튜브의 비디오 스트리밍은 롱테일(long-tail) 분포를 따른다.
    - 인기 있는 비디오는 빈번히 재생되는 반면, 나머지는 거의 보는 사람이 없다.
- 롱테일 분포에 따라 다음과 같이 최적화를 시도해볼 수 있다.
    1. 인기 비디오는 CDN을 통해 재생하되, 다른 비디오는 비디오 서버를 통해 재생하는 것이다.

        ![image](https://github.com/yu-heejin/system-design-interview-study/assets/96467030/5f6ab634-8c53-48ff-84eb-af1cd7512d02)

    2. 인기가 별로 없는 비디오는 인코딩 할 필요가 없을 수도 있다. 짧은 비디오라면 필요할 때 인코딩하여 재생할 수 있다.
    3. 어떤 비디오는 특정 지역에서만 인기가 높다. 이런 비디오는 다른 지역에 옮길 필요가 없다.
    4. CDN을 직접 구축하고 인터넷 서비스 제공자(ISP)와 제휴한다. 
- 이러한 모든 최적화는 콘텐츠 인기도, 이용 패턴, 비디오 크기 등의 데이터에 근거한 것이다.
    - 따라서 최적화 시도 전 시청 패턴을 분석해야한다.

### 오류 처리

- 시스템 오류에는 다음과 같이 두 종류가 있다.
    - 회복 가능 오류(recoverable error): 특정 비디오 세그먼트를 트랜스코딩하다 실패한 오류는 회복 가능한 오류에 속한다.
    - 회복 불가능 오류(non-recoverable error): 비디오 포맷이 잘못되었다거나하는 회복 불가능한 오류가 발견되면 시스템은 해당 비디오에 대한 작업을 중단하고 클라이언트에게 적절한 오류 코드를 반환해야한다.
- 다음은 발생할 수 있는 오류에 대한 전형적인 해결책이다.
    - 업로드 오류: 재시도
    - 비디오 분할 오류: 낡은 버전의 클라이언트가 GOP 경계에 따라 비디오를 분할하지 못하는 경우라면 전체 비디오를 서버로 전송하고 서버가 해당 비디오 분할을 처리하도록 한다.
    - 트랜스코딩 오류: 재시도
    - 전처리 오류: 그래프 재생성
    - DAG 스케줄러 오류: 작업을 다시 스케줄링한다.
    - 자원 관리자 큐에 장애 발생: 사본(replica)을 이용한다.
    - 작업 서버 장애: 다른 서버에서 해당 작업을 재시도한다.
    - API 서버 장애: API 서버는 무상태 서버이므로 신규 요청은 다른 API 서버로 우회될 것이다.
    - 메타데이터 캐시 서버 장애: 데이터는 다중화되어 있으므로 다른 노드에서 데이터를 여전히 가져올 수 있다. 장애가 난 캐시 서버는 새로운 것으로 교체한다.
    - 메타데이터 데이터베이스 서버 장애
        - 주 서버가 죽었다면 부 서버 가운데 하나를 주 서버로 교체한다.
        - 부 서버가 죽었다면 다른 부 서버를 통해 읽기 연산을 처리하고 죽은 서버는 새것으로 교체한다.

## [4단계] 마무리

- API 계층의 규모 확장성 방안: API 서버는 무상태 서버이므로 수평적 규모 확장이 가능하다는 사실을 언급하면 좋다.
- 데이터베이스 계층의 규모 확장성 확보 방안: 데이터베이스의 다중화와 샤딩방법
- 라이브 스트리밍(live streaming): 책에서 설명한 것은 라이브 스트리밍 설계는 아니지만 라이브 스트리밍과 비라이브 스트리밍 시스템간 비슷한 점이 많다.
    - 둘 모두 비디오 업로드, 인코딩, 스트리밍이 필요하다는 점에서는 같다.
    - 라이브 스트리밍의 경우 병렬화 필요성은 떨어지는데, 작은 단위의 데이터를 실시간으로 빨리 처리해야하기 때문이다.
    - 라이브 스트리밍의 경우 오류 처리 방법을 달리 해야한다. 오랜 시간이 걸리는 방안은 사용하기 어렵다.
