# 12장 채팅 시스템 설계

채팅 앱이라고 했을 때 사람들이 떠올리는 것은 제각각이다. 그러니 요구사항을 확실하게 해 두는 것이 아주 중요하다.

## 1단계. 문제 이해 및 설계 범위 확정
어떤 채팅 앱을 설계하려는지 확실히 해 두는 것이 면접에서 가장 중요하다.

> Q1.어떤 앱을 설계해야 하나요? 1:1 채팅 앱입니까 아니면 그룹 채팅 앱입니까?
> Q2.모바일 앱인가요 아니면 웹 앱인가요?
> Q3.처리해야 하는 트래픽 규모는 어느 정도입니까?
> Q4.그룹 채팅의 경우에 인원 제한이 있습니까?
> Q5.중요 기능으로는 어던 것이 있을까요? 가령, 첨부파일도 지원할 수 있어야 하나요?
> Q6.메시지 길이에 제한이 있나요?
> Q7.종단 간 암호화(end-to-end encryption)를 지원해야 하나요?
> Q8.채팅 이력은 얼마나 오래 보관해야 할까요?

**요구사항**
* 응답 지연이 낮은 일대이 채팅 기능
* 최대 100명까지 참여할 수 있는 그룹 채팅 기능
* 사용자의 접속상태 표시 기능
* 다양한 단말 지원. 하나의 계정으로 여러 단말에 동시 접속 지원
* 푸시 알림
* DAU 5천만


## 2단계. 개략적 설계안 제시 및 동의구하기

클라이언트는 서로 직접 통신하지 않는다.
* 클라이언트들로부터 메시지 수신
* 메시지 수신자(recipient) 결정 및 전달
* 수신자가 접속(online) 상태가 아닌 경우에는 접속할 떄까지 해당 메시지 보관

메시지 송신 클라이언트와 수신 클라이언트와 채팅 서비스 사이의 관계이다.

<img width="512" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/bbe4ef65-67dd-487f-a874-fce3df9cbfab">

채팅 서비스에서 어떤 통신 프로토콜을 사용할 것인가도 중요하다.

어떤 프로토콜을 사용할 것인가?

* 클라이언트/서버 애플리케이션에서 요청을 보내는 것은 클라이언트이다.
  * 채팅 시스템에서 메시지 송신 클라이언트가 해당 역할을 수행한다.
* HTTP 프로토콜을 사용하여 연결 후 송신자는 채팅 서비스에 수신자에게 메시지 전달을 요청한다.
* 여기서는 keep-alive 헤더를 사용하면 효율적이다.
  * TCP 접속과정에서 발생하는 handshake 횟수를 줄일 수 있다.
  
메시지 수신은 어떤 프로토콜을 사용할 것인가?

* HTTP는 클라이언트가 연결을 생성하는 프로토콜이다.
* 서버에서 클라이언트에게 임의 시점에 메시지 전달은 어렵다.
* 이를 해결하기 위한 폴링, 롱 폴링, 웹 소켓 기술을 사용할 수 있다.

### 폴링

<img width="545" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/e042e0f1-1f75-40ed-82d4-b2b601e6a2c7">

* 클라이언트가 주기적으로 서버에게 메시지 여부를 물어보는 방식이다.
* 폴링 비용은 주기가 짧을 수록 올라간다.
* 답할 메시지가 없을 경우 서버 자원이 낭비된다.

### 롱 폴링

<img width="500" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/4878e0f0-75c8-4eb0-a52f-e58f66c7aaeb">

* 폴링을 보완하는 기법이다.
* 클라이언트가 새 메시지가 반환되거나 타임아웃 될 떄까지 연결을 유지한다.
* 클라이언트는 새 메시지를 받으면(또는 타임아웃 시) 기존 연결을 종료하고 서버에 새로운 요청을 보내 모든 절차를 다시 시작한다.
* 다음과 같은 약점이 있다.
  * 송신자와 수신자가 같은 채팅 서버에 접속하지 않을 수 있다.
  * HTTP 서버들은 대부분 stateless 서버이며, 로드 밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우, 송신자와 수신자가 다른 채팅 서버를 사용할 수 있다.
  * 서버 입장에서 클라이언트와 연결 해제 여부를 알 수 없다.
  * 메시지를 받지않은 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 재접속해야하므로 여전히 비효율적이다.

### 웹소켓

<img width="496" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/c3aec674-ccba-4004-b742-28178c222b26">

* 웹 소켓은 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다.
* 연결은 클라이언트가 시작한다.
* 처음에 HTTP 연결 후, 특정 handshake 절차를 거치고 웹 소켓 연결로 업그레이드된다.
* 웹 소켓 연결은 항구적이며 양방향이다.
* HTTP/HTTPS의 80 또는 443 포트를 그대로 사용하기 때문에 방화벽 환경에서도 동작한다.

<img width="384" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/923229a5-d363-47a1-806c-9524a065a3d4">

* 웹소켓을 이용하면 송수신때 동일한 프로토콜을 사용할 수 있다.
  * 설계와 구현이 단순해짐
* 유의할 것은 웹소켓 연결은 항구적인 환경에서 효율적으로 관리 되어야 한다.

### 개략적 설계안

<img width="513" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/f5b35cc9-cc4e-4200-92e5-f8542fb92db8">

채팅을 제외한 대부분의 기능(회원가입, 로그인, 사용자 프로필 등)은 일반적인 HTTP로 구현해도 된다.
채팅 서비스는 무상태 서비스, 상태 유지 서비스, 제 3자 서비스 연동으로 구분 가능하다.

**무상태 서비스**
* 로그인, 회원강비, 사용자 프로파일 표시등을 처리하는 전통적인 요청/응답 서비스다.
* 로드밸런서 뒤에 위치한다.
  * 모놀리틱(monolithic) 서비스 또는 마이크로서비스일 수 있다.
* 서비스 탐색(service discovery) 서비스는 클라이언트가 접속할 채팅 서버의 DNS 호스트명을 알려주는 서비스이다.

**상태 유지 서비스**
* 채팅 서비스에 해당한다.
* 각 클라이언트가 채팅 서버와 독립적인 네트워크 연경르 유지해야 하기 때문
  * 클라이언트는 서버가 살아 있는 한  다른 서버로 연결을 변경하지 않는다.
* 앞에서 언급한 서비스 탐색은 체팅 서비스와 협력하여 특정 서버에 부하가 몰리지 않도록 한다.

### 규모 확장성

> 서버 한대로 구현을 하는 경우 동시 접속자가 1M이라 가정하고 접속당 10K의 서버 메모리가 필요한다고 하면<br>
>  -> 10GB 메모리만 있으면 모든 연결을 다 처리 할 수 있지만<br>
> 위와 같은 규모의 트래픽을 서버 한 대로 처리하면 매우 나쁘다<br>
> 예시로 SPOF(Single-Point-Of-Failure)<br>
> 하지만 서버 한 대로 시작해서 점차 다듬어 나가는 것도 괜찮다. 면접관에게 '이것은 그저 시작일 뿐' 이라는 것만 정확하게  전달해 놓으면 된다.

(지금 까지 설명한 것을 종합하면 다음과 같은 그림이 나온다.)

<img width="593" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/110156b9-a715-4735-982a-40e6b1966227">

* 채팅서버는 클라이언트 간 메시지 중계를 담당한다.
* 접속상태(presence) 서버는 사용자 접속 여부를 관리한다.
* API 서버는 채팅을 제외한 로그인, 회원가입 프로필 변경 등 전부를 처리한다.
* 알림 서버는 푸시 알림을 보낸다.
* 키-값 저장소에는 채팅 이력을 보관한다.
* 시스템에 접속한 사용자는 이전 채팅 이력을 전부 볼 것이다.

### 저장소
* 어떤 데이터베이스를 사용할 것인지는 데이터의 유형과 읽기/쓰기 연산의 패턴을 봐야한다.
* 채팅 시스템의 데이터는 두 가지다.
    1. 사용자 프로필, 설정, 친구 목록 등 일반 데이터
    2. 채팅 이력 (chat history)
* 일반 데이터는 데이터 안정성을 보장하는 관계형 데이터베이스에 보관한다.
* 채팅이력은 읽기/쓰기 연산 패턴을 이해해야한다.
  * 채팅 이력 데이터는 매우 크다.
    * 페이스북 메신저나 왓츠앱은 매일 600억 개의 메시지를 처리한다.
  * 이 데이터에서 가장 자주 사용되는 것은 최근 메시지이다.
    * 대부분 사용자는 오래된 메시지를 보지않는다.
  * 사용자는 대체로 최근 메시지를 보지만, 메시지 검색 기능, 특정 사용자가 언급된 메시지 보기, 특정 메시지로 점프하기 등 무작위 데이터 접근을 지원해야한다.
  * 1:1 채팅 앱의 경우 읽기:쓰기 비율은 대략 1:1이다.
* 위 사항을 바탕으로 채팅 이력은 키-값 저장소를 추천한다.
  * 수평적 규모확장이 쉽다.
  * 데이터 접근 지연시간이 낮다.
  * 관계형 데이터베이스는 long tail에 해당하는 부분을 잘 처리하지 못한다.
    * 인덱스가 커지면 데이터에 대한 random access 비용이 늘어난다.
  * 이미 많은 안정적인 채팅 시스템이 키-값 저장소를 사용한다.
    * 페이스북 메신저는 HBase를 사용하며 디스코드는 카산드라를 사용한다.

### 데이터 모델

**1:1 채팅을 위한 메시지 테이블** 

<img width="202" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/5dff6722-e8c6-4ed0-bb41-b729e4c6488a">

* message_id를 기본키로 가진다.

**그룹 채팅을 위한 메시지 테이블**

<img width="207" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/808840b4-cc28-49de-9c57-5722d145dc61">

* channel_id와 message_id의 복합키를 기본키로 사용한다.

**메시지 ID**

* message_id는 고유해야한다.
* ID 값은 정렬 가능해야 하면 시간 순서와 일치해야 한다. 
  1. 스노플레이크 방법( 7장 분산 시스템 설계 )
  2. 지역적 순서 번호 생성기
     *  message_id의 유일성은 같은 그룹 안에서만 보장하면 된다.
     *  전역에 비해 비교적 구현하기 쉽다

## 3단계 상세 설계
서비스탐색, 메시지 전달 흐름, 사용자 접속 상태에 대하여 보겠다.

### 서비스 탐색
* 클라이언트에게 가장 적합한 채팅 서버를 추천하는 것
* 기준은 클라이언트의 위치, 서버 용량 등이 있다.
* 대표적으로는 아파치 주키퍼가 있다.
* 사용가능한 모든 채팅 서버를 등록하고 클라이언트가 접속 시도 시, 기준에 따라 최적의 채팅 서버를 골라준다.

<img width="512" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/1d3215cb-b7e7-4651-a3eb-0108903afdd6">

1. A가 시스템에 로그인 시도
2. 로드밸런서가 로그인 요청을 API 서버에 보낸다.
3. API 서버가 인증 처리 후 서비스 탐색 기능을 통해 최적의 채팅 서버를 찾는다.
    -> 최적의 채팅 서버로 2를 반환한다고 가정
4. A는 채팅 서버 2와 웹 소켓 연결

### 메시지 흐름

**1:1 채팅 메시지 처리 흐름**

<img width="512" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/efb8772f-652f-4af4-a963-9a99f5931a8c">

1. A가 채팅 서버 1로 메시지 전송
2. 채팅 서버 1은 ID 생성기로 message_id 결정
3. 채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송
4. 메시지를 키-값 저장소에 저장
5. 
    a. B가 온라인인 경우, 메시지는 채팅 서버 2로 전송됨.<br>
    b. 오프라인인 경우, 메시지를 푸시 알림 서버로 전송
6. B와 채팅서버 2는 웹소켓으로 연결되어 있으며, 채팅서버 2가 B에게 메시지 전송.

**여러 단말 사이의 메시지 동기화**

<img width="540" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/b06b086c-deb2-4268-88fa-77b223ba13a5">

* 각 단말은 가장 최신 메시지 ID인 cur_max_message_id를 갖는다.
* 아래 두 조건을 만족한 경우 새 메시지로 간주한다.
  * 수신자 ID가 현재 로그인한 사용자 ID와 같은 경우
  * message_id가 cur_max_message_id보다 큰 경우

**소규모 그룹 채팅에서의 메시지 흐름**

<img width="459" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/d0156568-bf8a-4477-9236-7e1af3f307e7">

* A가 보낸 메시지는 B와 C의 메시지 큐에 복사된다.
* 새 메시지 여부는 본인 큐만 확인하면 되므로 단순하다.
* 그룹이 크지않으면 큐마다 복사하는 비용이 문제되지 않는다.
* 위챗은 이 방법을 쓰며 그룹 크기를 500명으로 제한한다.

<img width="519" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/1279b193-1666-4bb2-a056-c1d06029a7be">

* 수신자 관점으로 보면, 수신자는 여러 송신자에서 오는 메시지를 수신할 수 있어야한다.
* 즉, 메시지 큐는 여러 사용자의 메시지를 받을 수 있어야한다.
  
**접속상태 표시**

* 접속상태 표시는 채팅 애플리케이션의 핵심 기능이다.
  * 사용자 프로필 옆에 나타나는 녹색 불이 그것이다.
* 접속 상태 서버는 웹소켓으로 통신하는 실시간 서비스 중 하나이다.
* 사용자 상태가 변하는 로그인, 로그아웃, 접속 장애에 대해서 살펴보자.

**로그인**

<img width="502" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/64ece044-e28f-406e-8b62-48ba465386b8">

* 클라이언트가 웹 소켓 연결을 하고나면 접속 상태 서버는 유저 상태와 last_active_at 타임스탬프 값을 키-값 저장소에 보관한다.

**로그아웃**

<img width="589" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/5a484b70-f2d8-4e9a-a4fa-fff5802b38e6">

* 로그아웃 시 사용자 상태를 offline으로 바꾼다.
* 이때 UI 상에 사용자 상태는 접속 중이 아닌 것으로 표시된다.

**접속 장애**

<img width="533" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/a360df6b-acc0-45fe-b8ba-5f50488ead19">

* 인터넷 연결은 항상 안정적인 것은 아니다.
* 잠깐의 연결이 끊겼다고 매번 접속 상태를 변경하는 것은 오버헤드가 크다. ex) 터널 지나갈 때
* 이 문제는 heartbeat 검사를 통해 해결할 수 있다.
* 클라이언트는 주기적으로 heartbeat event를 접속상태 서버로 보낸다.
* 마지막 이벤트가 x초 이내에 다시 오면 온라인으로 유지하고 아닐 경우 오프라인으로 변경한다.
* 위 예시에서 x가 30초일 때, 클라이언트는 박동이벤트를 5초마다 보내다가 아무런 메시지를 보내지않아 오프라인으로 변경됐다.

**상태 정보의 전송**

<img width="484" alt="image" src="https://github.com/Dev-Books-Master-Study/system-design-interview/assets/87285536/eef53e19-27db-4758-8376-89b09e998c86">

* 친구들(B, C, D)는 A의 상태정보를 어떻게 알까?
* 접속상태 서버는 발행(publish)-구독(subscribe) 모델을 사용한다.
  * 각 친구관계마다 채널을 하나씩 둔다.
  * 위 예시에서는 A-B, A-C, A-D 채널이 존재
  * 각 채널을 각 친구들이 구독
* 이는 그룹의 크기가 작을 때 효과적이다. 동일 이벤트가 친구 수만큼 발생한다.
* 그룹이 클 경우 사용자가 그룹 채팅에 입장하는 순간에만 상태정보를 읽거나 사용자가 친구의 접속상태를 수동으로 갱신하는 방식을 사용한다.

# 4단계. 마무리

* 미디어 파일을 지원하는 방법
  * 미디어 파일은 용량이 크기 때문에 압축, 클라우드 저장소, 섬네일 생성 등을 논의할 수 있다.
* 종단 간 암호화
* 캐시
  * 이미 읽은 메시지를 캐시하면 서버와 주고받는 데이터를 줄일 수 있다.
* 로딩 속도 개선
  * 슬랙은 사용자 데이터, 채널 등을 지역적으로 분산하는 네트워크를 구축하여 앱 로딩 속도를 개선했다.
* 오류 처리
  * 채팅 서버 오류: 채팅 서버가 죽으면 서비스 탐색 서비스가 클라이언트에게 새로운 서버를 배정하고 재접속 할 수 있도록 해야한다.
  * 메시지 재전송: 재시도나 큐는 메시지의 안정적 전송을 보장하는 일반적인 기법이다.